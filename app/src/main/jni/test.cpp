/* DO NOT EDIT THIS FILE - it is machine generated */
#include <sample_change_me_clothesdetect_nativeMothed_NativeMothed.h>
#include <android/bitmap.h>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#ifdef __cplusplus
extern "C" {
#endif
using namespace std;
using namespace cv;
class ColorHistogram{
private :
    int histSize[3];		//每个维度的大小
    float hranges[2];		//值的范围
    const float* ranges[3]; //每个维度的范围
    int  channels[3];		//需要处理的通道
public :
    ColorHistogram(){
        //默认参数
        //每个维度的大小和范围是相等的
        histSize[0] = histSize[1] = histSize[2] = 256;
        hranges[0] = 0.0;	//BGR范围
        hranges[1] = 256.0;
        ranges[0] = hranges; //所有的通道的范围都相等
        ranges[1] = hranges;
        ranges[2] = hranges;
        channels[0] = 0;	//指定通道
        channels[1] = 1;
        channels[2] = 2;
    }
    void setSize(int Size){
        histSize[0]=histSize[1]=histSize[2]= Size;
    }
    Mat getHistogram(const Mat& image){
        Mat hist;

        //BGR 颜色直方图 范围
        hranges[0] = 0.0;
        hranges[1] = 256.0;
        channels[0] = 0;
        channels[1] = 1;
        channels[2] = 2;
        calcHist(&image,
                 1,
                 channels,
                 Mat(),
                 hist,
                 3,
                 histSize,
                 ranges);
        return hist;
    }
    SparseMat getSpareHistogram(const Mat &image){
        SparseMat hist(3,histSize, CV_32F);
        //BGR 颜色直方图
        hranges[0] = 0.0;
        hranges[1] = 256.0;
        channels[0] = 0;
        channels[1] = 1;
        channels[2] = 2;

        //计算直方图
        calcHist(&image,
                 1,
                 channels,
                 Mat(),
                 hist,
                 3,
                 histSize,
                 ranges);
        return hist;
    }

};

class ImageComparator{
private :
    Mat refH;
    Mat inputH;
    ColorHistogram hist;
    int nBins;
public:
    ImageComparator():nBins(8){
    }
    void setNumberOfBins(int bins){
        nBins = bins;
    }
    void setReferenceImage(const Mat &image){
        hist.setSize(nBins);
        refH = hist.getHistogram(image);
    }
    double compare(const Mat &image){
        inputH = hist.getHistogram(image);
        return compareHist(refH, inputH, CV_COMP_BHATTACHARYYA);
    }
};
void divMat(const Mat& image){
    Mat lookup(1, 256, CV_8U);
    int div = 64;
    for (int i = 0; i < 256; i++)
        lookup.at<uchar>(i) = i / div * div + div / 2;
    LUT(image, lookup, image);
}
ImageComparator C;
/*
 * Class:     sample_change_me_clothesdetect_nativeMothed_NativeMothed
 * Method:    nativeSetBaseImage
 * Signature: (Ljava/lang/Object;)V
 */
JNIEXPORT void JNICALL Java_sample_change_me_clothesdetect_nativeMothed_NativeMothed_nativeSetBaseImage
(JNIEnv  * env, jclass clazz, jobject bitmap){
    AndroidBitmapInfo bmp1info;
    void* bmp1pixels;
    int height,width,ret,y,x;
    //解析bitmap
    if ((ret = AndroidBitmap_getInfo(env, bitmap, &bmp1info)) < 0) {
    return;
    }
    if (bmp1info.format != ANDROID_BITMAP_FORMAT_RGBA_8888 || bmp1info.format != ANDROID_BITMAP_FORMAT_RGBA_8888) {
    return ;
    }
    if ((ret = AndroidBitmap_lockPixels(env, bitmap, &bmp1pixels)) < 0) {
    return ;
    }
    height = bmp1info.height;
    width = bmp1info.width;
    Mat image(height,width,CV_8UC4,bmp1pixels);
    Mat imagecopy;
    image.copyTo(imagecopy);
    //转换到HSV空间
    divMat(imagecopy);
    cvtColor(imagecopy, imagecopy, CV_RGB2HSV);
    //设置基准图片
    C.setReferenceImage(imagecopy);
    AndroidBitmap_unlockPixels(env, bitmap);
}

/*
 * Class:     sample_change_me_clothesdetect_nativeMothed_NativeMothed
 * Method:    nativeGetImage
 * Signature: (Ljava/lang/Object;)Z
 */
JNIEXPORT jboolean JNICALL Java_sample_change_me_clothesdetect_nativeMothed_NativeMothed_nativeGetImage
        (JNIEnv  * env, jclass clazz, jobject bitmap){
        AndroidBitmapInfo bmp2info;
        void* bmp2pixels;
        int height,width,ret,y,x;
        if ((ret = AndroidBitmap_getInfo(env, bitmap, &bmp2info)) < 0) {
        return false;
        }
        if (bmp2info.format != ANDROID_BITMAP_FORMAT_RGBA_8888 || bmp2info.format != ANDROID_BITMAP_FORMAT_RGBA_8888) {
        return false;
        }
        if ((ret = AndroidBitmap_lockPixels(env, bitmap, &bmp2pixels)) < 0) {
        return false;
        }
        height = bmp2info.height;
        width = bmp2info.width;
        Mat img(height,width,CV_8UC4,bmp2pixels);
        Mat imgcopy;
        //img.copyTo(imgcopy);
        Rect rect1(width/2-width/4, height/5, width/2+width/4, height-height/5);
        img(rect1).copyTo(imgcopy);
        divMat(imgcopy);
        //转换到HSV空间
        cvtColor(imgcopy, imgcopy, CV_RGB2HSV);
        float cmp= C.compare(imgcopy);
        AndroidBitmap_unlockPixels(env, bitmap);
        //CV_COMP_INTERSECT
        //if (C.compare(img)/piexl>0.57){
        //	imshow(index, img2);  //8
        //}
        //CV_COMP_CORREL
        //if (C.compare(img) > .7){
        //	imshow(index, img2); //7
        //}
        //CV_COMP_BHATTACHARYYA
        if (cmp>-0.5 && cmp<0.5){
        return true;
        }else
        return false;
}

#ifdef __cplusplus
}
#endif

